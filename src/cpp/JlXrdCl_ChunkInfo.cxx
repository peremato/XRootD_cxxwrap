// this file was auto-generated by wrapit 5168a24
#include "Wrapper.h"

#include "jlXRootD.h"
#include "dbg_msg.h"
#include "jlcxx/functions.hpp"
#include "jlcxx/stl.hpp"

namespace jlcxx {
  template<> struct IsMirroredType<XrdCl::ChunkInfo> : std::false_type { };
  template<> struct DefaultConstructible<XrdCl::ChunkInfo> : std::false_type { };
}

// Class generating the wrapper for type XrdCl::ChunkInfo
// signature to use in the veto file: XrdCl::ChunkInfo
struct JlXrdCl_ChunkInfo: public Wrapper {

  JlXrdCl_ChunkInfo(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type XrdCl::ChunkInfo (" __HERE__ ")");
    // defined in /Users/mato/.julia/artifacts/8520a52585f5eadf78b58f2d486d1abb34f514f1/include/xrootd/XrdCl/XrdClXRootDResponses.hh:916:10
    jlcxx::TypeWrapper<XrdCl::ChunkInfo>  t = jlModule.add_type<XrdCl::ChunkInfo>("XrdCl!ChunkInfo");
    jlcxx::stl::apply_stl<XrdCl::ChunkInfo>(jlModule);
    type_ = std::unique_ptr<jlcxx::TypeWrapper<XrdCl::ChunkInfo>>(new jlcxx::TypeWrapper<XrdCl::ChunkInfo>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void XrdCl::ChunkInfo::ChunkInfo(uint64_t, uint32_t, void *) (" __HERE__ ")");
    // defined in /Users/mato/.julia/artifacts/8520a52585f5eadf78b58f2d486d1abb34f514f1/include/xrootd/XrdCl/XrdClXRootDResponses.hh:921:5
    t.constructor<uint64_t>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<uint64_t, uint32_t>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<uint64_t, uint32_t, void *>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for uint64_t XrdCl::ChunkInfo::GetOffset() (" __HERE__ ")");
    // signature to use in the veto list: uint64_t XrdCl::ChunkInfo::GetOffset()
    // defined in /Users/mato/.julia/artifacts/8520a52585f5eadf78b58f2d486d1abb34f514f1/include/xrootd/XrdCl/XrdClXRootDResponses.hh:927:21
    t.method("GetOffset", static_cast<uint64_t (XrdCl::ChunkInfo::*)()  const>(&XrdCl::ChunkInfo::GetOffset));

    DEBUG_MSG("Adding wrapper for uint32_t XrdCl::ChunkInfo::GetLength() (" __HERE__ ")");
    // signature to use in the veto list: uint32_t XrdCl::ChunkInfo::GetLength()
    // defined in /Users/mato/.julia/artifacts/8520a52585f5eadf78b58f2d486d1abb34f514f1/include/xrootd/XrdCl/XrdClXRootDResponses.hh:935:21
    t.method("GetLength", static_cast<uint32_t (XrdCl::ChunkInfo::*)()  const>(&XrdCl::ChunkInfo::GetLength));

    DEBUG_MSG("Adding wrapper for void * XrdCl::ChunkInfo::GetBuffer() (" __HERE__ ")");
    // signature to use in the veto list: void * XrdCl::ChunkInfo::GetBuffer()
    // defined in /Users/mato/.julia/artifacts/8520a52585f5eadf78b58f2d486d1abb34f514f1/include/xrootd/XrdCl/XrdClXRootDResponses.hh:943:18
    t.method("GetBuffer", static_cast<void * (XrdCl::ChunkInfo::*)() >(&XrdCl::ChunkInfo::GetBuffer));

    DEBUG_MSG("Adding offset methods  to provide read access to the field offset (" __HERE__ ")");
    // defined in /Users/mato/.julia/artifacts/8520a52585f5eadf78b58f2d486d1abb34f514f1/include/xrootd/XrdCl/XrdClXRootDResponses.hh:948:15
    // signature to use in the veto list: XrdCl::ChunkInfo::offset
    t.method("offset", [](const XrdCl::ChunkInfo& a) -> uint64_t { return a.offset; });
    t.method("offset", [](XrdCl::ChunkInfo& a) -> uint64_t { return a.offset; });
    t.method("offset", [](const XrdCl::ChunkInfo* a) -> uint64_t { return a->offset; });
    t.method("offset", [](XrdCl::ChunkInfo* a) -> uint64_t { return a->offset; });
    // defined in /Users/mato/.julia/artifacts/8520a52585f5eadf78b58f2d486d1abb34f514f1/include/xrootd/XrdCl/XrdClXRootDResponses.hh:948:15
    // signature to use in the veto list: XrdCl::ChunkInfo::offset
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding offset! methods to provide write access to the field offset (" __HERE__ ")");
    t.method("offset!", [](XrdCl::ChunkInfo& a, uint64_t val) -> uint64_t { return a.offset = val; });

    DEBUG_MSG("Adding offset! methods to provide write access to the field offset (" __HERE__ ")");
    t.method("offset!", [](XrdCl::ChunkInfo* a, uint64_t val) -> uint64_t { return a->offset = val; });

    DEBUG_MSG("Adding length methods  to provide read access to the field length (" __HERE__ ")");
    // defined in /Users/mato/.julia/artifacts/8520a52585f5eadf78b58f2d486d1abb34f514f1/include/xrootd/XrdCl/XrdClXRootDResponses.hh:949:15
    // signature to use in the veto list: XrdCl::ChunkInfo::length
    t.method("length", [](const XrdCl::ChunkInfo& a) -> uint32_t { return a.length; });
    t.method("length", [](XrdCl::ChunkInfo& a) -> uint32_t { return a.length; });
    t.method("length", [](const XrdCl::ChunkInfo* a) -> uint32_t { return a->length; });
    t.method("length", [](XrdCl::ChunkInfo* a) -> uint32_t { return a->length; });
    // defined in /Users/mato/.julia/artifacts/8520a52585f5eadf78b58f2d486d1abb34f514f1/include/xrootd/XrdCl/XrdClXRootDResponses.hh:949:15
    // signature to use in the veto list: XrdCl::ChunkInfo::length
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding length! methods to provide write access to the field length (" __HERE__ ")");
    t.method("length!", [](XrdCl::ChunkInfo& a, uint32_t val) -> uint32_t { return a.length = val; });

    DEBUG_MSG("Adding length! methods to provide write access to the field length (" __HERE__ ")");
    t.method("length!", [](XrdCl::ChunkInfo* a, uint32_t val) -> uint32_t { return a->length = val; });

    DEBUG_MSG("Adding buffer methods  to provide read access to the field buffer (" __HERE__ ")");
    // defined in /Users/mato/.julia/artifacts/8520a52585f5eadf78b58f2d486d1abb34f514f1/include/xrootd/XrdCl/XrdClXRootDResponses.hh:950:15
    // signature to use in the veto list: XrdCl::ChunkInfo::buffer
    t.method("buffer", [](const XrdCl::ChunkInfo& a) -> void * { return a.buffer; });
    t.method("buffer", [](XrdCl::ChunkInfo& a) -> void * { return a.buffer; });
    t.method("buffer", [](const XrdCl::ChunkInfo* a) -> void * { return a->buffer; });
    t.method("buffer", [](XrdCl::ChunkInfo* a) -> void * { return a->buffer; });
    // defined in /Users/mato/.julia/artifacts/8520a52585f5eadf78b58f2d486d1abb34f514f1/include/xrootd/XrdCl/XrdClXRootDResponses.hh:950:15
    // signature to use in the veto list: XrdCl::ChunkInfo::buffer
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding buffer! methods to provide write access to the field buffer (" __HERE__ ")");
    t.method("buffer!", [](XrdCl::ChunkInfo& a, void * val) -> void * { return a.buffer = val; });

    DEBUG_MSG("Adding buffer! methods to provide write access to the field buffer (" __HERE__ ")");
    t.method("buffer!", [](XrdCl::ChunkInfo* a, void * val) -> void * { return a->buffer = val; });
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<XrdCl::ChunkInfo>> type_;
};
std::shared_ptr<Wrapper> newJlXrdCl_ChunkInfo(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlXrdCl_ChunkInfo(module));
}
