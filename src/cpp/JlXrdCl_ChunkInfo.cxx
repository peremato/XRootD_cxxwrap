// this file was auto-generated by wrapit v1.6.0
#include "Wrapper.h"

#include "jlXRootD.h"
#include "dbg_msg.h"
#include "jlcxx/functions.hpp"
#include "jlcxx/stl.hpp"

namespace jlcxx {
  template<> struct IsMirroredType<XrdCl::ChunkInfo> : std::false_type { };
  template<> struct DefaultConstructible<XrdCl::ChunkInfo> : std::false_type { };
}

// Class generating the wrapper for type XrdCl::ChunkInfo
// signature to use in the veto file: XrdCl::ChunkInfo
struct JlXrdCl_ChunkInfo: public Wrapper {

  JlXrdCl_ChunkInfo(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type XrdCl::ChunkInfo (" __HERE__ ")");
    // defined in /Users/mato/.julia/artifacts/d7f8626a7055397045bff10d1f18132236662705/include/xrootd/XrdCl/XrdClXRootDResponses.hh:917:10
    jlcxx::TypeWrapper<XrdCl::ChunkInfo>  t = jlModule.add_type<XrdCl::ChunkInfo>("XrdCl!ChunkInfo");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<XrdCl::ChunkInfo>>(new jlcxx::TypeWrapper<XrdCl::ChunkInfo>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes    );


    DEBUG_MSG("Adding wrapper for void XrdCl::ChunkInfo::ChunkInfo(uint64_t, uint32_t, void *) (" __HERE__ ")");
    // defined in /Users/mato/.julia/artifacts/d7f8626a7055397045bff10d1f18132236662705/include/xrootd/XrdCl/XrdClXRootDResponses.hh:922:5
    t.constructor<uint64_t>(/*finalize=*/jlcxx::finalize_policy::yes, jlcxx::arg("this"), jlcxx::arg("off")    );
    t.constructor<uint64_t, uint32_t>(/*finalize=*/jlcxx::finalize_policy::yes, jlcxx::arg("this"), jlcxx::arg("off"), jlcxx::arg("len")    );
    t.constructor<uint64_t, uint32_t, void *>(/*finalize=*/jlcxx::finalize_policy::yes, jlcxx::arg("this"), jlcxx::arg("off"), jlcxx::arg("len"), jlcxx::arg("buff")    );

    DEBUG_MSG("Adding wrapper for uint64_t XrdCl::ChunkInfo::GetOffset() (" __HERE__ ")");
    // signature to use in the veto list: uint64_t XrdCl::ChunkInfo::GetOffset()
    // defined in /Users/mato/.julia/artifacts/d7f8626a7055397045bff10d1f18132236662705/include/xrootd/XrdCl/XrdClXRootDResponses.hh:928:21
    t.method("GetOffset", [](XrdCl::ChunkInfo const& a)->uint64_t { return a.GetOffset(); }, jlcxx::arg("this"));
    t.method("GetOffset", [](XrdCl::ChunkInfo const* a)->uint64_t { return a->GetOffset(); }, jlcxx::arg("this"));

    DEBUG_MSG("Adding wrapper for uint32_t XrdCl::ChunkInfo::GetLength() (" __HERE__ ")");
    // signature to use in the veto list: uint32_t XrdCl::ChunkInfo::GetLength()
    // defined in /Users/mato/.julia/artifacts/d7f8626a7055397045bff10d1f18132236662705/include/xrootd/XrdCl/XrdClXRootDResponses.hh:936:21
    t.method("GetLength", [](XrdCl::ChunkInfo const& a)->uint32_t { return a.GetLength(); }, jlcxx::arg("this"));
    t.method("GetLength", [](XrdCl::ChunkInfo const* a)->uint32_t { return a->GetLength(); }, jlcxx::arg("this"));

    DEBUG_MSG("Adding wrapper for void * XrdCl::ChunkInfo::GetBuffer() (" __HERE__ ")");
    // signature to use in the veto list: void * XrdCl::ChunkInfo::GetBuffer()
    // defined in /Users/mato/.julia/artifacts/d7f8626a7055397045bff10d1f18132236662705/include/xrootd/XrdCl/XrdClXRootDResponses.hh:944:18
    t.method("GetBuffer", [](XrdCl::ChunkInfo& a)->void * { return a.GetBuffer(); }, jlcxx::arg("this"));
    t.method("GetBuffer", [](XrdCl::ChunkInfo* a)->void * { return a->GetBuffer(); }, jlcxx::arg("this"));

    DEBUG_MSG("Adding offset methods  to provide read access to the field offset (" __HERE__ ")");
    // defined in /Users/mato/.julia/artifacts/d7f8626a7055397045bff10d1f18132236662705/include/xrootd/XrdCl/XrdClXRootDResponses.hh:949:15
    // signature to use in the veto list: XrdCl::ChunkInfo::offset
    t.method("offset", [](const XrdCl::ChunkInfo& a) -> uint64_t { return a.offset; }, jlcxx::arg("this"));
    t.method("offset", [](XrdCl::ChunkInfo& a) -> uint64_t { return a.offset; }, jlcxx::arg("this"));
    t.method("offset", [](const XrdCl::ChunkInfo* a) -> uint64_t { return a->offset; }, jlcxx::arg("this"));
    t.method("offset", [](XrdCl::ChunkInfo* a) -> uint64_t { return a->offset; }, jlcxx::arg("this"));
    // defined in /Users/mato/.julia/artifacts/d7f8626a7055397045bff10d1f18132236662705/include/xrootd/XrdCl/XrdClXRootDResponses.hh:949:15
    // signature to use in the veto list: XrdCl::ChunkInfo::offset
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding offset! methods to provide write access to the field offset (" __HERE__ ")");
    t.method("offset!", [](XrdCl::ChunkInfo& a, uint64_t val) -> uint64_t { return a.offset = val; }, jlcxx::arg("this"), jlcxx::arg("value"));

    DEBUG_MSG("Adding offset! methods to provide write access to the field offset (" __HERE__ ")");
    t.method("offset!", [](XrdCl::ChunkInfo* a, uint64_t val) -> uint64_t { return a->offset = val; }, jlcxx::arg("this"), jlcxx::arg("value"));

    DEBUG_MSG("Adding length methods  to provide read access to the field length (" __HERE__ ")");
    // defined in /Users/mato/.julia/artifacts/d7f8626a7055397045bff10d1f18132236662705/include/xrootd/XrdCl/XrdClXRootDResponses.hh:950:15
    // signature to use in the veto list: XrdCl::ChunkInfo::length
    t.method("length", [](const XrdCl::ChunkInfo& a) -> uint32_t { return a.length; }, jlcxx::arg("this"));
    t.method("length", [](XrdCl::ChunkInfo& a) -> uint32_t { return a.length; }, jlcxx::arg("this"));
    t.method("length", [](const XrdCl::ChunkInfo* a) -> uint32_t { return a->length; }, jlcxx::arg("this"));
    t.method("length", [](XrdCl::ChunkInfo* a) -> uint32_t { return a->length; }, jlcxx::arg("this"));
    // defined in /Users/mato/.julia/artifacts/d7f8626a7055397045bff10d1f18132236662705/include/xrootd/XrdCl/XrdClXRootDResponses.hh:950:15
    // signature to use in the veto list: XrdCl::ChunkInfo::length
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding length! methods to provide write access to the field length (" __HERE__ ")");
    t.method("length!", [](XrdCl::ChunkInfo& a, uint32_t val) -> uint32_t { return a.length = val; }, jlcxx::arg("this"), jlcxx::arg("value"));

    DEBUG_MSG("Adding length! methods to provide write access to the field length (" __HERE__ ")");
    t.method("length!", [](XrdCl::ChunkInfo* a, uint32_t val) -> uint32_t { return a->length = val; }, jlcxx::arg("this"), jlcxx::arg("value"));

    DEBUG_MSG("Adding buffer methods  to provide read access to the field buffer (" __HERE__ ")");
    // defined in /Users/mato/.julia/artifacts/d7f8626a7055397045bff10d1f18132236662705/include/xrootd/XrdCl/XrdClXRootDResponses.hh:951:15
    // signature to use in the veto list: XrdCl::ChunkInfo::buffer
    t.method("buffer", [](const XrdCl::ChunkInfo& a) -> void * { return a.buffer; }, jlcxx::arg("this"));
    t.method("buffer", [](XrdCl::ChunkInfo& a) -> void * { return a.buffer; }, jlcxx::arg("this"));
    t.method("buffer", [](const XrdCl::ChunkInfo* a) -> void * { return a->buffer; }, jlcxx::arg("this"));
    t.method("buffer", [](XrdCl::ChunkInfo* a) -> void * { return a->buffer; }, jlcxx::arg("this"));
    // defined in /Users/mato/.julia/artifacts/d7f8626a7055397045bff10d1f18132236662705/include/xrootd/XrdCl/XrdClXRootDResponses.hh:951:15
    // signature to use in the veto list: XrdCl::ChunkInfo::buffer
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding buffer! methods to provide write access to the field buffer (" __HERE__ ")");
    t.method("buffer!", [](XrdCl::ChunkInfo& a, void * val) -> void * { return a.buffer = val; }, jlcxx::arg("this"), jlcxx::arg("value"));

    DEBUG_MSG("Adding buffer! methods to provide write access to the field buffer (" __HERE__ ")");
    t.method("buffer!", [](XrdCl::ChunkInfo* a, void * val) -> void * { return a->buffer = val; }, jlcxx::arg("this"), jlcxx::arg("value"));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<XrdCl::ChunkInfo>> type_;
};
std::shared_ptr<Wrapper> newJlXrdCl_ChunkInfo(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlXrdCl_ChunkInfo(module));
}
