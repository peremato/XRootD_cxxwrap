// this file was auto-generated by wrapit v1.6.0
#include "Wrapper.h"

#include "jlXRootD.h"
#include "dbg_msg.h"
#include "jlcxx/functions.hpp"
#include "jlcxx/stl.hpp"

namespace jlcxx {
  template<> struct IsMirroredType<XrdCl::Status> : std::false_type { };
  template<> struct DefaultConstructible<XrdCl::Status> : std::false_type { };
}

// Class generating the wrapper for type XrdCl::Status
// signature to use in the veto file: XrdCl::Status
struct JlXrdCl_Status: public Wrapper {

  JlXrdCl_Status(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type XrdCl::Status (" __HERE__ ")");
    // defined in /Users/mato/.julia/artifacts/d7f8626a7055397045bff10d1f18132236662705/include/xrootd/XrdCl/XrdClStatus.hh:114:10
    jlcxx::TypeWrapper<XrdCl::Status>  t = jlModule.add_type<XrdCl::Status>("XrdCl!Status");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<XrdCl::Status>>(new jlcxx::TypeWrapper<XrdCl::Status>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes    );


    DEBUG_MSG("Adding wrapper for void XrdCl::Status::Status(uint16_t, uint16_t, uint32_t) (" __HERE__ ")");
    // defined in /Users/mato/.julia/artifacts/d7f8626a7055397045bff10d1f18132236662705/include/xrootd/XrdCl/XrdClStatus.hh:119:5
    t.constructor<uint16_t>(/*finalize=*/jlcxx::finalize_policy::yes, jlcxx::arg("this"), jlcxx::arg("st")    );
    t.constructor<uint16_t, uint16_t>(/*finalize=*/jlcxx::finalize_policy::yes, jlcxx::arg("this"), jlcxx::arg("st"), jlcxx::arg("cod")    );
    t.constructor<uint16_t, uint16_t, uint32_t>(/*finalize=*/jlcxx::finalize_policy::yes, jlcxx::arg("this"), jlcxx::arg("st"), jlcxx::arg("cod"), jlcxx::arg("errN")    );

    DEBUG_MSG("Adding wrapper for bool XrdCl::Status::IsError() (" __HERE__ ")");
    // signature to use in the veto list: bool XrdCl::Status::IsError()
    // defined in /Users/mato/.julia/artifacts/d7f8626a7055397045bff10d1f18132236662705/include/xrootd/XrdCl/XrdClStatus.hh:122:10
    t.method("IsError", [](XrdCl::Status const& a)->bool { return a.IsError(); }, jlcxx::arg("this"));
    t.method("IsError", [](XrdCl::Status const* a)->bool { return a->IsError(); }, jlcxx::arg("this"));

    DEBUG_MSG("Adding wrapper for bool XrdCl::Status::IsFatal() (" __HERE__ ")");
    // signature to use in the veto list: bool XrdCl::Status::IsFatal()
    // defined in /Users/mato/.julia/artifacts/d7f8626a7055397045bff10d1f18132236662705/include/xrootd/XrdCl/XrdClStatus.hh:123:10
    t.method("IsFatal", [](XrdCl::Status const& a)->bool { return a.IsFatal(); }, jlcxx::arg("this"));
    t.method("IsFatal", [](XrdCl::Status const* a)->bool { return a->IsFatal(); }, jlcxx::arg("this"));

    DEBUG_MSG("Adding wrapper for bool XrdCl::Status::IsOK() (" __HERE__ ")");
    // signature to use in the veto list: bool XrdCl::Status::IsOK()
    // defined in /Users/mato/.julia/artifacts/d7f8626a7055397045bff10d1f18132236662705/include/xrootd/XrdCl/XrdClStatus.hh:124:10
    t.method("IsOK", [](XrdCl::Status const& a)->bool { return a.IsOK(); }, jlcxx::arg("this"));
    t.method("IsOK", [](XrdCl::Status const* a)->bool { return a->IsOK(); }, jlcxx::arg("this"));

    DEBUG_MSG("Adding wrapper for int XrdCl::Status::GetShellCode() (" __HERE__ ")");
    // signature to use in the veto list: int XrdCl::Status::GetShellCode()
    // defined in /Users/mato/.julia/artifacts/d7f8626a7055397045bff10d1f18132236662705/include/xrootd/XrdCl/XrdClStatus.hh:129:9
    t.method("GetShellCode", [](XrdCl::Status const& a)->int { return a.GetShellCode(); }, jlcxx::arg("this"));
    t.method("GetShellCode", [](XrdCl::Status const* a)->int { return a->GetShellCode(); }, jlcxx::arg("this"));

    DEBUG_MSG("Adding wrapper for bool XrdCl::Status::IsSocketError(uint16_t) (" __HERE__ ")");
    // signature to use in the veto list: bool XrdCl::Status::IsSocketError(uint16_t)
    // defined in /Users/mato/.julia/artifacts/d7f8626a7055397045bff10d1f18132236662705/include/xrootd/XrdCl/XrdClStatus.hh:136:24
    module_.method("XrdCl!Status!IsSocketError", [](uint16_t arg0)->bool { return XrdCl::Status::IsSocketError(arg0); }, jlcxx::arg("code"));

    DEBUG_MSG("Adding wrapper for std::string XrdCl::Status::ToString() (" __HERE__ ")");
    // signature to use in the veto list: std::string XrdCl::Status::ToString()
    // defined in /Users/mato/.julia/artifacts/d7f8626a7055397045bff10d1f18132236662705/include/xrootd/XrdCl/XrdClStatus.hh:144:17
    t.method("ToString", [](XrdCl::Status const& a)->std::string { return a.ToString(); }, jlcxx::arg("this"));
    t.method("ToString", [](XrdCl::Status const* a)->std::string { return a->ToString(); }, jlcxx::arg("this"));

    DEBUG_MSG("Adding status methods  to provide read access to the field status (" __HERE__ ")");
    // defined in /Users/mato/.julia/artifacts/d7f8626a7055397045bff10d1f18132236662705/include/xrootd/XrdCl/XrdClStatus.hh:146:14
    // signature to use in the veto list: XrdCl::Status::status
    t.method("status", [](const XrdCl::Status& a) -> uint16_t { return a.status; }, jlcxx::arg("this"));
    t.method("status", [](XrdCl::Status& a) -> uint16_t { return a.status; }, jlcxx::arg("this"));
    t.method("status", [](const XrdCl::Status* a) -> uint16_t { return a->status; }, jlcxx::arg("this"));
    t.method("status", [](XrdCl::Status* a) -> uint16_t { return a->status; }, jlcxx::arg("this"));
    // defined in /Users/mato/.julia/artifacts/d7f8626a7055397045bff10d1f18132236662705/include/xrootd/XrdCl/XrdClStatus.hh:146:14
    // signature to use in the veto list: XrdCl::Status::status
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding status! methods to provide write access to the field status (" __HERE__ ")");
    t.method("status!", [](XrdCl::Status& a, uint16_t val) -> uint16_t { return a.status = val; }, jlcxx::arg("this"), jlcxx::arg("value"));

    DEBUG_MSG("Adding status! methods to provide write access to the field status (" __HERE__ ")");
    t.method("status!", [](XrdCl::Status* a, uint16_t val) -> uint16_t { return a->status = val; }, jlcxx::arg("this"), jlcxx::arg("value"));

    DEBUG_MSG("Adding code methods  to provide read access to the field code (" __HERE__ ")");
    // defined in /Users/mato/.julia/artifacts/d7f8626a7055397045bff10d1f18132236662705/include/xrootd/XrdCl/XrdClStatus.hh:147:14
    // signature to use in the veto list: XrdCl::Status::code
    t.method("code", [](const XrdCl::Status& a) -> uint16_t { return a.code; }, jlcxx::arg("this"));
    t.method("code", [](XrdCl::Status& a) -> uint16_t { return a.code; }, jlcxx::arg("this"));
    t.method("code", [](const XrdCl::Status* a) -> uint16_t { return a->code; }, jlcxx::arg("this"));
    t.method("code", [](XrdCl::Status* a) -> uint16_t { return a->code; }, jlcxx::arg("this"));
    // defined in /Users/mato/.julia/artifacts/d7f8626a7055397045bff10d1f18132236662705/include/xrootd/XrdCl/XrdClStatus.hh:147:14
    // signature to use in the veto list: XrdCl::Status::code
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding code! methods to provide write access to the field code (" __HERE__ ")");
    t.method("code!", [](XrdCl::Status& a, uint16_t val) -> uint16_t { return a.code = val; }, jlcxx::arg("this"), jlcxx::arg("value"));

    DEBUG_MSG("Adding code! methods to provide write access to the field code (" __HERE__ ")");
    t.method("code!", [](XrdCl::Status* a, uint16_t val) -> uint16_t { return a->code = val; }, jlcxx::arg("this"), jlcxx::arg("value"));

    DEBUG_MSG("Adding errNo methods  to provide read access to the field errNo (" __HERE__ ")");
    // defined in /Users/mato/.julia/artifacts/d7f8626a7055397045bff10d1f18132236662705/include/xrootd/XrdCl/XrdClStatus.hh:148:14
    // signature to use in the veto list: XrdCl::Status::errNo
    t.method("errNo", [](const XrdCl::Status& a) -> uint32_t { return a.errNo; }, jlcxx::arg("this"));
    t.method("errNo", [](XrdCl::Status& a) -> uint32_t { return a.errNo; }, jlcxx::arg("this"));
    t.method("errNo", [](const XrdCl::Status* a) -> uint32_t { return a->errNo; }, jlcxx::arg("this"));
    t.method("errNo", [](XrdCl::Status* a) -> uint32_t { return a->errNo; }, jlcxx::arg("this"));
    // defined in /Users/mato/.julia/artifacts/d7f8626a7055397045bff10d1f18132236662705/include/xrootd/XrdCl/XrdClStatus.hh:148:14
    // signature to use in the veto list: XrdCl::Status::errNo
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding errNo! methods to provide write access to the field errNo (" __HERE__ ")");
    t.method("errNo!", [](XrdCl::Status& a, uint32_t val) -> uint32_t { return a.errNo = val; }, jlcxx::arg("this"), jlcxx::arg("value"));

    DEBUG_MSG("Adding errNo! methods to provide write access to the field errNo (" __HERE__ ")");
    t.method("errNo!", [](XrdCl::Status* a, uint32_t val) -> uint32_t { return a->errNo = val; }, jlcxx::arg("this"), jlcxx::arg("value"));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<XrdCl::Status>> type_;
};
std::shared_ptr<Wrapper> newJlXrdCl_Status(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlXrdCl_Status(module));
}
